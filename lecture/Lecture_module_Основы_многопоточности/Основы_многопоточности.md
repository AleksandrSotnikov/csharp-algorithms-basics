# Основы многопоточности в C#

В этом модуле изучается параллельное программирование: работа с потоками, асинхронные задачи, синхронизация данных, проблемы конкуренции и deadlock.

## Теоретическая основа

### Потоки в .NET

Поток — независимая единица выполнения кода:
```csharp
Thread thread = new Thread(() => Console.WriteLine("В потоке!"));
thread.Start();
```
Можно запускать несколько потоков параллельно для повышения скорости работы приложения.

### Пул потоков

`ThreadPool` — оптимизированный набор потоков, используемых для небольших задач:
```csharp
ThreadPool.QueueUserWorkItem(state => Console.WriteLine("Из пула потоков!"));
```

### Асинхронное программирование: async/await

Асинхронные методы позволяют не блокировать основной поток:
```csharp
async Task<int> ComputeAsync() {
    await Task.Delay(1000);
    return 100;
}
int r = await ComputeAsync();
```

### Синхронизация и Deadlock

При работе с общими данными нужна синхронизация:
```csharp
object locker = new object();
lock (locker) {
    // критическая секция
}
```
Без корректной синхронизации появляется риск взаимной блокировки (deadlock).

## Практические рекомендации
- Используйте async/await для сетевых, файловых и длительных операций.
- Предпочитайте ThreadPool для коротких задач с минимальной инициализацией.
- Всегда защищайте доступ к общим данным через lock или специальные коллекции (ConcurrentBag, ConcurrentDictionary).

## Практические задания
1. Запустите 5 параллельных потоков, которые считают сумму чисел от 1 до 1000.
2. Реализуйте асинхронную загрузку файла и вывод его содержимого на экран.
3. Продемонстрируйте проблему deadlock, а затем решите её через корректную организацию lock.
4. Используйте пул потоков для параллельной обработки массива.

## Материалы для изучения
- Microsoft Docs: https://docs.microsoft.com/ru-ru/dotnet/standard/threading/
- Видеоуроки: https://metanit.com/sharp/tutorial/9.1.php